#pragma config(Sensor, S1,     Wall,           sensorEV3_Ultrasonic)
#pragma config(Sensor, S2,     Bumper,         sensorEV3_Touch)
#pragma config(Sensor, S3,     Light,          sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     Ball,           sensorSONAR)
#pragma config(Motor,  motorA,          RightMotor,    tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          Grabber,       tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          LeftMotor,     tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// BallGrabber is a program designed for compatibility with the Lego EV3 robot.
//
// It is designed to avoid walls on its sides, turn around when it bumps into a
// wall with its front bumper, and sense for a red ball with an attached color
// sensor. When it receives input for the red ball, it will trigger the grabber
// function to pick up the ball in front of its path. Finally, it will ignore
// balls that do not match the color it is programmed to look for.
//
// Written by Scott Harrington and Patrick Sellers

// wall sensor globals
bool wallBool= false;
bool distanceBool= false;

bool celebrate= false;

//bumper sensor globals
bool bumpberBool= false;

//color sensor globals
bool colorBool= false;
bool colorRight= false;

// indicates whether the ball has been found or not.
bool FOUNDBALL = false;
bool empty = true;


const int wallConst= 10;
const int distanceConst= 50;

string goDo = "foward";

// This is a method that syncs the motors to move in a clock-wise
// rotation to reverse the movement of the robot and go for a given
// time.
void reverse (int duration, int motorPower)
{
	setMotorSyncTime(RightMotor, LeftMotor , 0, duration, motorPower);
	wait1Msec(duration);
}

// This method adjusts the robot to the left approximately 90 degrees.
void rotateLeft()
{
	setMotorSyncEncoder(RightMotor, LeftMotor, -100, 500, 25);
	waitUntilMotorStop(LeftMotor);

}

// This method adjusts the robot to the right approximately 90 degrees.
void rotateRight()
{
	setMotorSyncEncoder(RightMotor, LeftMotor, 100, 500, 25);
	waitUntilMotorStop(RightMotor);
}

// This task will check to see if the robot is near the wall, checking
// it against a constant predetermined value, and returns true if it
// is too close to the wall.
task wallSensor()
{
	while(true){
		if(SensorValue[Wall] < wallConst)
		{
			wallBool = true;

		}
		else
			{
			wallBool = false;


		}

	}
	releaseCPU();
}

// This sensor checks to see if an object can be seen by
// the distance sensor on the left-hand side. If so, it
// reports that the ball is found.
task BallSensor()
{
	while(true){

		if(SensorValue[Ball] < distanceConst)
		{
			FOUNDBALL= true;
		}
		else
		{
			FOUNDBALL = false;
		}
		releaseCPU();

	}


		releaseCPU();
}

// This task checks to see if the front bumper has been triggered.
// If the value returned is less than 1, then the bumper is read as
// triggered and the bumper boolean value will return as true.
task bumperSensor()
{
		while(true){
			if(SensorValue[Bumper] < 1)
		{
			bumpberBool=true;
		}
		else{
			bumpberBool=false;
		}
		releaseCPU();
	}
}

// This task checks to see if the object in front of it is red, or if
// what is in the robot's path has some other color value. If no color
// above the threshold is detected, then the robot returns false for
// both sensing the right color, and sensing any color at all.
task lightSensor()
{
	while(true)
	{
		if(getColorName(Light)== colorRed)
		{
			colorBool = false;
			colorRight= true;
			;

		}
		else if(getColorName(Light)== colorBlue)
		{
			colorBool=true;
			colorRight= false;
		}
		else
	  {
			colorBool=false;
			colorRight= false;
	  }
		releaseCPU();
	}
}

// This method reopens the grabber claw by activating the motor.
void undoGrabber()
{
		Motor[Grabber]=10;

		wait1Msec(5000);
		Motor[Grabber]=0;
}

// This is the method that actually performs the action that is given to
// it by the global action variable.
void gogogo(string action)
{
	if(action == "turn" )
	{
		rotateRight();
		waitUntilMotorStop(RightMotor);
	}

	// If the string is forward then the robot will move forward for a
	// period of time.
	if(action == "walk")
	{
		setMotorSyncTime(RightMotor, LeftMotor, 0, 100, 100)
		waitUntilMotorStop(LeftMotor);
	}
	if(action == "followfar")
	{

		setMotorSyncEncoder(RightMotor, LeftMotor, -80, 30, 100);
		waitUntilMotorStop(LeftMotor);
		setMotorSyncTime(RightMotor,LeftMotor, 0, 100, 100);
		wait1Msec(100);
	}

	//
	if(action == "follownear")
	{
		setMotorSyncEncoder(RightMotor, LeftMotor, 80, 30, 100);
		waitUntilMotorStop(RightMotor);
		setMotorSyncTime(RightMotor,LeftMotor, 0, 100, 100);
		wait1Msec(100);
	}

	// If the robot hits a wall, it will perform a reverse and then
	// a right turn.
	if(action == "reverse")
	{
		reverse(700, -50);
		rotateRight();
	}

	// if the color of the ball is not red, it will run away from
	// the ball by going backwards
	if(action == "wrongball" )
	{

		setMotorSyncTime(RightMotor, LeftMotor, 0, 2000, -100);
		waitUntilMotorStop(RightMotor);
	}

	// if grab is the triggered action, it will close its claws around
	// the ball below it.
	if(action == "grab" )
	{
		motor[Grabber]=-10;
		wait1Msec(5000);
		motor[Grabber]=0;
		empty = false;
		celebrate= true;
	}

	// If the ball has been successfully grabbed, then the robot
	// will initiate a celebratory dance.
	if(action == "celebrate" )
	{
		setMotorSyncTime(RightMotor, LeftMotor, 0, 3000, 100);
		playTone(soundBlip);
		waitUntilMotorStop(RightMotor);
	}
}

// This is the method that actually runs the robot by starting task loops
// and making an appropriate decision based on the state of the sensors.
task main()
{
	startTask (BallSensor);
	startTask (wallSensor);
	startTask (bumperSensor);
	startTask (lightSensor );


		undoGrabber();
		while(true)
		{
			while(true)
				{
					goDo = "walk";
					if(wallBool)
					{
						goDo = "follownear";
					}
						if(FOUNDBALL)
					{
						goDo= "turn";
					}
					if(colorBool & empty)
					{
						goDo = "wrongball";
					}
					if(colorRight & empty)
					{
						goDo = "grab";
					}
					if(celebrate)
					{
						goDo="celebrate";
					}
					if(bumpberBool)
					{
						goDo = "reverse";
					}

					gogogo(goDo);
				}
		}
}
