#pragma config(Sensor, S1,     LightSensor1,   sensorEV3_Color, modeEV3Color_Ambient)
#pragma config(Sensor, S2,     DistanceSensor, sensorSONAR)
#pragma config(Sensor, S3,     Bump,           sensorEV3_Touch)
#pragma config(Motor,  motorA,          RightMotor,    tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          LeftMotor,     tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

bool LightSensorBool= false;
bool TouchSensorBool= false;
bool DistanceSensorBool=false;
bool SoundSensorBool=false;

task LightSensorTask()
{
	while(true){
		if(SensorValue[LightSensor1] < 10)
		{
			//LightSensorBool =true;
			LightSensorBool = true;
		}
		else{
			LightSensorBool =false;

		}
		releaseCPU();
	}
}
task TouchSensorTask()
{
	while(true){
		if(SensorValue[Bump] < 1)
		{
			TouchSensorBool=true;
		}
		else{
			TouchSensorBool=false;
		}
		releaseCPU();
	}
}
task DistanceSensorTask()
{
	while(true){
		if(SensorValue[DistanceSensor] > 20 || SensorValue[DistanceSensor] <10)
		{
			DistanceSensorBool=true;
		}
		else{
			DistanceSensorBool=false;

		}
		releaseCPU();
	}
}


void reverse (int duration, int motorPower)
{
	setMotorSyncTime(RightMotor, LeftMotor , 0, duration, motorPower);
	wait1Msec(duration);
}
void rotateLeft()
{
	setMotorSyncEncoder(RightMotor, LeftMotor, -100, 500, 25);
	waitUntilMotorStop(LeftMotor);

}
void rotateRight()
{
	setMotorSyncEncoder(RightMotor, LeftMotor, 100, 500, 25);
	waitUntilMotorStop(RightMotor);
}
void TheMove(string action)
{

	if(action== "Foward")
	{
		setMotorSyncTime(RightMotor, LeftMotor, 0, 100, 100);
		wait1Msec(100);

	}
	// this case should never happen ( i think)
	if(action== "Wall")
	{
		//		setMotorSyncTime(RightMotor, LeftMotor , 0, 1000, -25);
		//		wait1Msec(1000);
		reverse(700, -50);
		//		setMotorSyncEncoder(RightMotor, LeftMotor, 100, 500, 25);
		//		waitUntilMotorStop(RightMotor);
		rotateRight();


	}

	if(action== "EmptyRightTurn")
	{
		//		setMotorSyncTime(RightMotor, LeftMotor, 0, 2000, 25);
		//		waitUntilMotorStop(RightMotor);
		////	setMotorSyncEncoder(RightMotor, LeftMotor, -100, 500, 25);
		////		waitUntilMotorStop(LeftMotor);
		//		rotateLeft();
		//		setMotorSyncTime(RightMotor, LeftMotor, 0, 2000, 25);
		//		waitUntilMotorStop(RightMotor);
		//			setMotorSyncTime(RightMotor, LeftMotor, 0, 1000, 25);
		//			waitUntilMotorStop(RightMotor);

		setMotorSyncTime(RightMotor, LeftMotor, 0, 1500, 25);
		waitUntilMotorStop(RightMotor);
		setMotorSyncEncoder(RightMotor, LeftMotor, -40 , 1300, 25);
		waitUntilMotorStop(RightMotor);
		setMotorSyncTime(RightMotor, LeftMotor, 0, 1500, 25);
		waitUntilMotorStop(RightMotor);


	}

	if(action== "RightTurn")
	{
		setMotorSync(RightMotor, LeftMotor, -100, 25);
		wait1Msec(100);
		setMotorSyncEncoder(RightMotor, LeftMotor, 0, 5, 100);
		waitUntilMotorStop(RightMotor);
	}
	if(action== "LeftTurn")
	{
		setMotorSync(RightMotor, LeftMotor, 100, 25);
		wait1Msec(100);
		setMotorSyncEncoder(RightMotor, LeftMotor, 0, 5, 100);
		waitUntilMotorStop(RightMotor);


	}
	if(action== "ReverseRightTurn")
	{
		//		setMotorSyncTime(RightMotor, LeftMotor , 0, 1000, -25);
		//		wait1Msec(1000);
		reverse(700, -50);

		//		setMotorSyncEncoder(RightMotor, LeftMotor, -100, 500, 25);
		//		waitUntilMotorStop(LeftMotor);
		rotateRight();



	}
	if(action=="Nothing")
	{
	}
}
task main()
{
	string WhatToDo = "Forward";

	startTask (LightSensorTask);
	startTask (TouchSensorTask);
	startTask (DistanceSensorTask);
	//	const string Startup = "Mike.rso";
	//	PlaySoundFile(Startup);

	while(true)
	{
		WhatToDo= "Foward";
		if(DistanceSensorBool)
		{
			if(SensorValue[DistanceSensor] <10)
			{
				WhatToDo= "LeftTurn";
			}
			else if (SensorValue[DistanceSensor] <25)
			{
				WhatToDo= "RightTurn";
			}
			else
			{

				WhatToDo= "EmptyRightTurn";
			}
		}
		if(TouchSensorBool)
		{
			WhatToDo="Wall";
		}
		if(TouchSensorBool & DistanceSensorBool)
		{
			WhatToDo="ReverseRightTurn";
		}
		if(LightSensorBool)
		{
			WhatToDo="Nothing";
		}
		TheMove(WhatToDo);

	}



}
